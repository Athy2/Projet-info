
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdbool.h> //pour les bool√©ens



#define COLOR(X) "\x1b["X"m"    //macro pour ajouter la couleur facilement, le X est l'emplacement du code couleur, au forma "nombre"
typedef struct square_table {
    char charactere;
    bool variable;
    int different;
} square_table;







void Display(square_table tab[][20], int size) {
    int i, j, k, l;
    
    for (i = 0; i < size; i++) {
        printf("\n \n");
        
        for (l = 0; l < size; l++) {
            if (l == size - 1) {
                printf("+---+\n"); // Ligne de fin de s√©paration
                break;
            } else {
                printf("+---"); // Ligne √† multiplier de s√©paration
            }
        }
        
        for (k = 0; k < size; k++) {
            if (tab[i][k].variable == 1) {
                printf("|");
                printf("\x1b[31m O ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'A') {
                printf("|");
                printf("\x1b[32m A ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'B') {
                printf("|");
                printf("\x1b[33m B ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'C') {
                printf("|");
                printf("\x1b[34m C ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'D') {
                printf("|");
                printf("\x1b[35m D ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'E') {
                printf("|");
                printf("\x1b[36m E ");
                printf(COLOR("%d"), 0);
            } else if (tab[i][k].charactere == 'F') {
                printf("|");
                printf("\x1b[37m F ");
                printf(COLOR("%d"), 0);
            }
        }
        printf("|"); // Barre de fin
    }
    
    printf("\n");
    
    for (l = 0; l < size; l++) {
        if (l == size - 1) {
            printf("+---+\n"); // Ligne de fin de s√©paration
        } 
        else {
            printf("+---"); // Ligne √† multiplier de s√©paration
        }
    }
}



void Displaymoji(square_table tab[][20],int size){ // Display du table √† modifier pendant la s√©ance d'info
    int i,j,k,l,m;
        for(i=0;i<size;i++){
            printf("\n \n");
            if(i==0){
                for(m=0;m<size;m++){        //Display des chiffres en hauteur
                    printf("   %d.",m);
                }
                printf("\n ");      
            }
            else{
            printf(" ");
            }
            for (l = 0; l < size; l++) {
                if (l == size - 1) {
                    printf("+----+\n"); // Ligne de fin de s√©paration
                }
                else {
                printf("+----"); // Ligne √† multiplier de s√©paration
                }
            }
                for(k=0;k<size;k++){
                    if(k==0){
                printf("%d",i);   
            }
            if(tab[i][k].variable==1){
                printf("|");
                printf("\x1b[31m O ");
                printf(COLOR("%d"),0);
                
            }
            else if(tab[i][k].charactere=='A'){
                printf("|");
                printf(" üçê ");
                
            }
            else if(tab[i][k].charactere=='B'){
                printf("|");
                printf(" üçâ ");
            }
            else if(tab[i][k].charactere=='C'){
                printf("|");
                printf(" ü•ù ");
                
            }
            else if(tab[i][k].charactere=='D'){
                printf("|");
                printf(" üçá ");
                
            }
            else if(tab[i][k].charactere=='E'){
                printf("|");
                printf(" üßÅ ");
                printf(COLOR("%d"),0);
            }
            else if(tab[i][k].charactere=='F'){
                printf("|");
                printf(" ü•ï ");
                printf(COLOR("%d"),0);
            }
        }
        printf("|"); // Barre de fin
    } 
    printf("\n");
    printf(" ");
    for (l = 0; l < size; l++) {
        if (l == size - 1) {
            printf("+----+\n"); // Ligne de fin de s√©paration
        } 
        else{
            printf("+----"); // Ligne √† multiplier de s√©paration
        }
    }
}

bool detect_mark(square_table tab[][20],int size,bool verif_quick) {
    int ol, oc; // optimisation fin du k en ligne et colonne
    bool verif = 0;
    verif_quick = 0; // bool√©en pour v√©rifier qu'il ne reste aucune ligne ou colonne de 3 ou plus
    int i, j, k, l, m, o;
    
    for (int i = 0; i < size; i++) {
        ol=size;
        for (int j = 0; j < ol; j++) {
            if(j==0){
                oc=size;
                int counter = 1; // initialisation des counters √† 1
                int counterlow=1;
                while (counter < size && tab[i][counter].charactere == tab[i][j].charactere) {
                counter++; // compter le nombre d'√©l√©ments √©gaux vers la droite
                }
                while (size-counterlow >=0 && tab[i][size - counterlow].charactere == tab[i][0].charactere) {
                counterlow++; // compter le nombre d'√©l√©ments √©gaux vers la droite
                }
                if (counter >= 3&&counterlow<=1) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                    for (int k = 0; k < counter; k++) {
                        tab[i][k].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    verif_quick=1;
                }
                if ((counterlow >= 3&&counter<=1)){
                    tab[i][0].variable=1; // remplacer du premier √©l√©ments par un "O"
                    for (int k = size+1-counterlow; k < size ; k++) {
                        tab[i][k].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    ol=size-counterlow; //optimisation fin de ligne
                    verif_quick=1;
                }
                if (counterlow+counter>=4&&counter>=1&&counterlow>=1){
                    for (int k = 0; k < counter; k++) {
                        tab[i][k].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    for (int k = size + 1 - counterlow; k<size ; k++) {
                        tab[i][k].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    ol=size-counterlow; //optimisation fin de ligne
                    verif_quick=1;
                }
            }
            if(i==0){
                int counter = 1; // r√©initialisation des counters √† 1
                int counterlow=1; 
                while (size-counterlow >=0 && tab[size - counterlow][j].charactere == tab[i][j].charactere) {
                counterlow++; // compter le nombre d'√©l√©ments √©gaux vers la droite
                }
                while (counter < size && tab[i + counter][j].charactere == tab[i][j].charactere) {
                    counter++; // compter le nombre d'√©l√©ments √©gaux vers le bas
                }
                if (counter >= 3&&counterlow==1) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                    for (int k = 0; k < counter; k++) {
                        tab[k][j].variable=1; // remplacer les √©l√©ments par des "O"
                        verif_quick=1;
                        
                    }
                }
                if (counterlow >= 3&&counter==1){
                    tab[0][j].variable=1; // remplacer du premier √©l√©ments par un "O"
                    for (int k = size+1-counterlow; k <size ; k++) {
                        tab[k][j].variable=1; // remplacer les √©l√©ments par des "O"
                        verif_quick=1;
                        
                    }
                oc=size-counterlow;
                }
                if (counterlow+counter>=4&&counter!=1&&counterlow!=1){
                    for (int k = 0; k < counter; k++) {
                        tab[k][j].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    for (int k = size+1 -counterlow; k < size; k++) {
                        tab[k][j].variable=1; // remplacer les √©l√©ments par des "O"
                       
                    }
                oc=size-counterlow; //optimisation fin de ligne
                verif_quick=1;
                }
            }
            int counter = 1; // initialisation du counter √† 1
            while (j + counter < size && tab[i][j + counter].charactere == tab[i][j].charactere) {
                counter++; // compter le nombre d'√©l√©ments √©gaux vers la droite
            }
            if (counter >= 3) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                for (int k = 0; k < counter; k++) {
                    tab[i][j+k].variable=1; // remplacer les √©l√©ments par des "O"
                }
            }
            counter = 1; // r√©initialisation du counter √† 1
            while (i + counter < size && tab[i + counter][j].charactere == tab[i][j].charactere) {
                counter++; // compter le nombre d'√©l√©ments √©gaux vers le bas
            }
            if (counter >= 3) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                for (int k = 0; k < counter; k++) {
                    tab[i+k][j].variable=1; // remplacer les √©l√©ments par des "O"
                }
            }
        
        
        
            for (int j = 0; j < size; j++) {
                int counter = 1; // initialisation du counter √† 1
                while (j + counter < size && tab[i][j + counter].charactere == tab[i][j].charactere) {
                    counter++; // compter le nombre d'√©l√©ments √©gaux vers la droite
                }
                if (counter >= 3) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                    for (int k = 0; k < counter; k++) {
                        tab[i][j+k].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    verif_quick=1;
                }
                counter = 1; // r√©initialisation du counter √† 1
                while (i + counter < size && tab[i + counter][j].charactere == tab[i][j].charactere) {
                    counter++; // compter le nombre d'√©l√©ments √©gaux vers le bas
                }
                if (counter >= 3) { // si on a trouv√© une s√©rie d'au moins 3 √©l√©ments √©gaux
                    for (int k = 0; k < counter; k++) {
                        tab[i+k][j].variable=1; // remplacer les √©l√©ments par des "O"
                    }
                    verif_quick=1;
                }
            }
        }        
    }
    return verif_quick;
}

void move_left(square_table tab[][20],int size) {
    int i,j,k;
    bool verif=0;
    
    
    
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            if (tab[i][j].variable == 1) {
                k = j;
                while (k > 0 && tab[i][k - 1].variable == 0) {
                    // √âchanger le caract√®re (avec son bool√©en pr√©c√©dent!!!!)
                    char tempcharactere = tab[i][k - 1].charactere;
                    int tempVariable = tab[i][k - 1].variable;
                    tab[i][k - 1].charactere = tab[i][k].charactere;
                    tab[i][k - 1].variable = tab[i][k].variable;
                    tab[i][k].charactere = tempcharactere;
                    tab[i][k].variable = tempVariable;
                    k--;
                }
            }
        }
    }


    

}


double replacement(square_table tab[][20],int size,int different,long score){
    int i, j, k;
    bool verif=0;
    bool verif_quick;
    int size2;
    size2=size;
    
    
    
    
    do{             // replacement de tout les caract√®res avec un bool√©en = 1 
        verif_quick=detect_mark(tab,size2,verif_quick); // v√©riftot ici sert √† d√©tecter si le programme detect_mark change une variable d'un caract√®re 
        move_left(tab,size2);
        for(i=0;i<size;i++){
            verif=0;
            for(k=0;k<size;k++){ // G√©n√©ration al√©atoire des caract√®res
                if(tab[i][k].variable==1){
                    verif=1;
                    tab[i][k].charactere='A'+rand()%different; //  symboles diff√©rents choisi par l'utilisateur
                    tab[i][k].variable=0; // variable √† zero pour le counter
                    score++;
                }
            }
        }
        
    }while(verif==1 || verif_quick==1);    //le do while ici sert pour ne pas sortir de la boucle tant que un des deux bool√©ens est √©gale √† 1
    return score;
}
void exchange(square_table tab[][20],int size){
  int a1, b1, a2, b2;    //a1 : ligne de la 1√®re square √† √©changer et b1 : colonne de cette 1√®re square
                         // pareil pour a2 et b2
  a1=0;
  b1=0;
  a2=0;
  b2=0;
  int temp;
  int i, k;
  square_table tabcopie[20][20]; 
  bool verif_quick;
  verif_quick=0;
    for (i = 0; i < size; i++) {
        for (k = 0; k < size; k++) {
        tabcopie[i][k].charactere = tab[i][k].charactere;
        tabcopie[i][k].variable = tab[i][k].variable;
        }
    }
  
  //boucle pour recommencer apr√®s chaque √©change  
  int erreur=0; 
    char square1, square2;
do{
    
    do{  //pour v√©rifier l'inverse : on veut que les a et b soient compris entre 0 et _ inclus
      printf("\nDonnez les coordonn√©es de la 1√®re square : ligne, puis colonne\n"); 
      scanf("%d",&a1);
      scanf("%d",&b1);
    }while (a1<0 || a1>=size || b1<0 || b1>=size );
    square1=tabcopie[a1][b1].charactere;
    
    printf("square1: ");
    if(square1=='A'){
      printf(" üçê \n");
    }
    else if(square1=='B'){
      printf(" üçâ \n");
    }
    else if(square1=='C'){
      printf(" ü•ù \n");
    }
    else if(square1=='D'){
      printf(" üçá \n");               
    }
    else if(square1=='E'){
      printf(" üßÅ \n");
      //printf(COLOR("%d"),0);
    }
    else if(square1=='F'){
      printf(" ü•ï \n");
      //printf(COLOR("%d"),0);
    }


    do{
      printf("Donnez les coordonn√©es de la 2nd square : ligne, puis colonne\n");
      scanf("%d",&a2);
      scanf("%d",&b2);
    }while (a2<0 || a2>=size || b2<0 || b2>=size);
    square2=tabcopie[a2][b2].charactere;

    printf("square2: ");
    if(square2=='A'){
      printf(" üçê \n");
    }
    else if(square2=='B'){
      printf(" üçâ \n");
    }
    else if(square2=='C'){
      printf(" ü•ù \n");
    }
    else if(square2=='D'){
      printf(" üçá \n");               
    }
    else if(square2=='E'){
      printf(" üßÅ \n");
      //printf(COLOR("%d"),0);
    }
    else if(square2=='F'){
      printf(" ü•ï \n");
      //printf(COLOR("%d"),0);
    }





    
  if (((a1==a2)&&((b1==b2+1)||(b1==b2-1))) || ((b1==b2)&&((a1==a2+1)||(a1==a2-1)))){  //condition pour v√©rifier que les squares soient √† c√¥t√©s ou au-dessus/dessous
    printf("condition ok\n");
    square1=tabcopie[a2][b2].charactere;    //√©change de la square1 par la square2
    square2=tabcopie[a1][b1].charactere;    //pareil mais pour square2 par square1
    temp=tabcopie[a1][b1].charactere;
    tabcopie[a1][b1].charactere=tabcopie[a2][b2].charactere;
    tabcopie[a2][b2].charactere=temp;
    verif_quick=detect_mark(tabcopie, size, verif_quick);

    if(verif_quick==1){
      printf("square1 √©chang√©e: ");
        if(square1=='A'){
          printf(" üçê \n");
        }
        else if(square1=='B'){
          printf(" üçâ \n");
        }
        else if(square1=='C'){
          printf(" ü•ù \n");
        }
        else if(square1=='D'){
          printf(" üçá \n");               
        }
        else if(square1=='E'){
          printf(" üßÅ \n");
          
        }
        else if(square1=='F'){
          printf(" ü•ï \n");
         
      }
    

      printf("square2 √©chang√©e: ");
        if(square2=='A'){
          printf(" üçê \n");
        }
        else if(square2=='B'){
          printf(" üçâ \n");
        }
        else if(square2=='C'){
          printf(" ü•ù \n");
        }
        else if(square2=='D'){
          printf(" üçá \n");               
        }
        else if(square2=='E'){
          printf(" üßÅ \n");
          
        }
        else if(square2=='F'){
          printf(" ü•ï \n");
        
        }
    
    }


    
    
  }
  else if((a1==a2)&&((b1==0 && b2==size-1)||(b1==size-1 && b2==0))){    //condition sp√©ciale o√π les 2 squares √† √©changer sont aux extr√™mit√©s de la m√™me ligne
    printf("ok ligne\n");  //pour v√©rifier cette codition
    square1=tabcopie[a2][b2].charactere;    //√©change de la square1 par la square2
    square2=tabcopie[a1][b1].charactere;    //pareil mais pour square2 par square1
    temp=tabcopie[a1][b1].charactere;
    tabcopie[a1][b1].charactere=tabcopie[a2][b2].charactere;
    tabcopie[a2][b2].charactere=temp;
    verif_quick=detect_mark(tabcopie, size, verif_quick);
if(verif_quick==1){
      printf("square1 √©chang√©e: ");
        if(square1=='A'){
          printf(" üçê \n");
        }
        else if(square1=='B'){
          printf(" üçâ \n");
        }
        else if(square1=='C'){
          printf(" ü•ù \n");
        }
        else if(square1=='D'){
          printf(" üçá \n");               
        }
        else if(square1=='E'){
          printf(" üßÅ \n");
          
        }
        else if(square1=='F'){
          printf(" ü•ï \n");
         
      }
    

      printf("square2 √©chang√©e: ");
        if(square2=='A'){
          printf(" üçê \n");
        }
        else if(square2=='B'){
          printf(" üçâ \n");
        }
        else if(square2=='C'){
          printf(" ü•ù \n");
        }
        else if(square2=='D'){
          printf(" üçá \n");               
        }
        else if(square2=='E'){
          printf(" üßÅ \n");
          
        }
        else if(square2=='F'){
          printf(" ü•ï \n");
        
        }
    
    }



    
  }
  else if((b1==b2)&&((a1==0 && a2==size-1)||(a1==size-1 && a2==0))){ //condition sp√©ciale o√π les 2 squares √† √©changer sont aux extr√™mit√©s de la m√™me colonne
    printf("ok colonne\n");
    square1=tabcopie[a2][b2].charactere;    //√©change de la square1 par la square2
    square2=tabcopie[a1][b1].charactere;    //pareil mais pour square2 par square1
    temp=tabcopie[a1][b1].charactere;
    tabcopie[a1][b1].charactere=tabcopie[a2][b2].charactere;
    tabcopie[a2][b2].charactere=temp;
    verif_quick=detect_mark(tabcopie, size, verif_quick);
    if(verif_quick==1){
      printf("square1 √©chang√©e: ");
        if(square1=='A'){
          printf(" üçê \n");
        }
        else if(square1=='B'){
          printf(" üçâ \n");
        }
        else if(square1=='C'){
          printf(" ü•ù \n");
        }
        else if(square1=='D'){
          printf(" üçá \n");               
        }
        else if(square1=='E'){
          printf(" üßÅ \n");
         
        }
        else if(square1=='F'){
          printf(" ü•ï \n");
         
      }
    

      printf("square2 √©chang√©e: ");
        if(square2=='A'){
          printf(" üçê \n");
        }
        else if(square2=='B'){
          printf(" üçâ \n");
        }
        else if(square2=='C'){
          printf(" ü•ù \n");
        }
        else if(square2=='D'){
          printf(" üçá \n");               
        }
        else if(square2=='E'){
          printf(" üßÅ \n");
          
        }
        else if(square2=='F'){
          printf(" ü•ï \n");
        
        }
    
    }
  }
if(verif_quick==0){
  printf("L'√©change de squares ne cr√©√© pas de colonne ou de ligne de trois ou plus veuillez entrer un √©change correct");
}
}while(verif_quick==0);  //v√©rifitot pour savoir si un alignement ligne/colonne de >=3 est ok
for (i = 0; i < size; i++) {
    for (k = 0; k < size; k++) {
    tab[i][k].charactere = tabcopie[i][k].charactere;
    tab[i][k].variable = tabcopie[i][k].variable;
    }
}


    
  


 

}


///////


bool detectionblocage(square_table tab[][20],int size){         //voir annexe des cas si besoin
    int i,j,k;
    bool verifblocage;
    verifblocage=1;
    for(i=0;i<size;i++){
        for(j=0;j<size;j++){
            if((tab[i][j].charactere==tab[i][j+1].charactere)&&(j>=2&&j<=size-4&&i>=1&&i<=size-2)){
                if(tab[i][j].charactere==tab[i][j-2].charactere||tab[i][j].charactere==tab[i-1][j-1].charactere||tab[i][j].charactere==tab[i+1][j-1].charactere||tab[i][j].charactere==tab[i][j+3].charactere||tab[i][j].charactere==tab[i-1][j+2].charactere||tab[i][j].charactere==tab[i+1][j+2].charactere){   //condition  pour le cas 1
                    return 0;    
                }
            }
            
            
            if(j==0){           //pour les doubles et simples sur la gauche         
                if(i>=1&&i<=size-2){
                    if(tab[i][0].charactere==tab[i][size-1].charactere){            
                        if(tab[i][0].charactere==tab[i][size-3].charactere||tab[i][0].charactere==tab[i-1][size-2].charactere||tab[i][0].charactere==tab[i+1][size-2].charactere||tab[i][0].charactere==tab[i-1][1].charactere||tab[i][0].charactere==tab[i+1][1].charactere||tab[i][0].charactere==tab[i][2].charactere){            //cas 2
                            return 0;
                        }
                    }
                    if(tab[i][0].charactere==tab[i][1].charactere){                   
                        if(tab[i][0].charactere==tab[i][size-2].charactere||tab[i][0].charactere==tab[i-1][size-1].charactere||tab[i][0].charactere==tab[i+1][size-1].charactere||tab[i][0].charactere==tab[i-1][2].charactere||tab[i][0].charactere==tab[i+1][2].charactere||tab[i][0].charactere==tab[i][3].charactere){    //cas 3
                            return 0;
                        }
                    }
                }
            }
            if(j==size-2){      //pour les doubles sur la droite
                if(i>=1&&i<=size-2){
                    if(tab[i][size-2].charactere==tab[i][size-1].charactere){            
                        if(tab[i][size-2].charactere==tab[i][size-4].charactere||tab[i][size-2].charactere==tab[i-1][size-3].charactere||tab[i][size-2].charactere==tab[i+1][size-3].charactere||tab[i][size-2].charactere==tab[i-1][0].charactere||tab[i][size-2].charactere==tab[i+1][0].charactere||tab[i][size-2].charactere==tab[i][1].charactere){            //cas 4
                            return 0;
                        }
                    }
                }
            }
            //les quatres cot√©es du table pour alignement de deux en ligne
            
            
            if(i==0&&j==0){                                     //cas 5
                if(tab[0][0].charactere==tab[0][1].charactere){            
                    if(tab[0][0].charactere==tab[0][size-2].charactere||tab[0][0].charactere==tab[size-1][size-1].charactere||tab[0][0].charactere==tab[1][size-1].charactere||tab[0][0].charactere==tab[0][3].charactere||tab[0][0].charactere==tab[1][2].charactere||tab[0][0].charactere==tab[size-1][2].charactere){    
                        return 0;
                    }
                }    
            }
            
            if(i==size-1&&j==0){  //cas 6
                if(tab[size-1][0].charactere==tab[size-1][1].charactere){            
                    if(tab[size-1][0].charactere==tab[size-1][size-2].charactere||tab[size-1][0].charactere==tab[size-2][size-1].charactere||tab[size-1][0].charactere==tab[0][size-1].charactere||tab[size-1][0].charactere==tab[size-1][3].charactere||tab[size-1][0].charactere==tab[size-2][2].charactere||tab[size-1][0].charactere==tab[0][2].charactere){    
                        return 0;
                    }
                }    
            }
            
            if(i==0&&j==size-2){                                     //cas 7
                if(tab[0][size-2].charactere==tab[0][size-1].charactere){            
                    if(tab[0][size-2].charactere==tab[0][size-4].charactere||tab[0][size-2].charactere==tab[size-1][size-3].charactere||tab[0][size-2].charactere==tab[1][size-3].charactere||tab[0][size-2].charactere==tab[0][1].charactere||tab[0][size-2].charactere==tab[1][0].charactere||tab[0][size-2].charactere==tab[size-1][0].charactere){        
                        return 0;
                    }
                }    
            }
            
            if(i==size-1&&j==size-2){                                       //cas 8
                if(tab[size-1][size-2].charactere==tab[size-1][size-1].charactere){            
                    if(tab[size-1][size-2].charactere==tab[0][0].charactere||tab[size-1][size-2].charactere==tab[size-2][0].charactere||tab[size-1][size-2].charactere==tab[size-1][1].charactere||tab[size-1][size-2].charactere==tab[size-1][size-4].charactere||tab[size-1][size-2].charactere==tab[size-2][size-3].charactere||tab[size-1][size-2].charactere==tab[0][size-3].charactere){    
                        return 0;
                    }
                }
            
            }
            //cas pour le haut et le bas
            if(i==size-1&&j==size-1){           //cas 9      
                if(tab[size-1][size-1].charactere==tab[size-1][0].charactere){            
                    if(tab[size-1][size-1].charactere==tab[size-1][size-3].charactere||tab[size-1][size-1].charactere==tab[size-2][size-2].charactere||tab[size-1][size-1].charactere==tab[0][size-2].charactere||tab[size-1][size-1].charactere==tab[size-1][2].charactere||tab[size-1][size-1].charactere==tab[size-2][1].charactere||tab[size-1][size-1].charactere==tab[size-2][1].charactere){ 
                        return 0;
                    } 
                }
            }
            
            if(i==0&&j==size-1){           //cas 10      
                if(tab[0][0].charactere==tab[0][size-1].charactere){            
                    if(tab[0][0].charactere==tab[0][size-3].charactere||tab[0][0].charactere==tab[1][size-2].charactere||tab[0][0].charactere==tab[size-1][size-2].charactere||tab[0][0].charactere==tab[0][2].charactere||tab[0][0].charactere==tab[size-1][1].charactere||tab[0][0].charactere==tab[1][1].charactere){ 
                        return 0;
                    } 
                }
            }
            
            
            
                    //suite √† faire pour les colonnes
            
            
            if((tab[i][j].charactere==tab[i+1][j].charactere)&&(j>=1&&j<=size-2&&i>=2&&i<=size-4)){
                if(tab[i][j].charactere==tab[i-2][j].charactere||tab[i][j].charactere==tab[i-1][j-1].charactere||tab[i][j].charactere==tab[i-1][j+1].charactere||tab[i][j].charactere==tab[i+2][j-1].charactere||tab[i][j].charactere==tab[i+2][j+1].charactere||tab[i][j].charactere==tab[i+3][j].charactere){   //condition  pour le cas 11
                    return 0;
                }
            }

        
                    
            if(i==0){           //pour les doubles et simples sur la gauche         
                if(j>=1&&j<=size-2){
                    if(tab[0][j].charactere==tab[size-1][j].charactere){            
                        if(tab[0][j].charactere==tab[size-3][j].charactere||tab[0][j].charactere==tab[size-2][j-1].charactere||tab[0][j].charactere==tab[size-2][j+1].charactere||tab[0][j].charactere==tab[1][j-1].charactere||tab[0][j].charactere==tab[1][j+1].charactere||tab[0][j].charactere==tab[2][j].charactere){            //cas 12
                            return 0;
                        } 
                    }
                    if(tab[0][j].charactere==tab[1][j].charactere){                   
                        if(tab[0][j].charactere==tab[size-2][j].charactere||tab[0][j].charactere==tab[size-1][j-1].charactere||tab[0][j].charactere==tab[size-1][j+1].charactere||tab[0][j].charactere==tab[2][j-1].charactere||tab[0][j].charactere==tab[2][j+1].charactere||tab[0][j].charactere==tab[3][j].charactere){    //cas 13
                            return 0;
                        }
                    }
                }
            }
            if(i==size-2){                        //cas 14 
                if(j>=1&&j<=size-2){
                    if(tab[size-2][j].charactere==tab[size-1][j].charactere){            
                        if(tab[size-2][j].charactere==tab[size-4][j].charactere||tab[size-2][j].charactere==tab[size-3][j-1].charactere||tab[size-2][j].charactere==tab[size-3][j+1].charactere||tab[size-2][j].charactere==tab[0][j-1].charactere||tab[size-2][j].charactere==tab[0][j+1].charactere||tab[size-2][j].charactere==tab[1][j].charactere){
                            return 0;
                        }
                    }
                }
            }
            if(i==0&&j==0){                             //cas 15
                if(tab[0][0].charactere==tab[1][0].charactere){            
                    if(tab[0][0].charactere==tab[size-2][0].charactere||tab[0][0].charactere==tab[size-1][1].charactere||tab[0][0].charactere==tab[size-1][size-1].charactere||tab[0][0].charactere==tab[3][0].charactere||tab[0][0].charactere==tab[2][1].charactere||tab[0][0].charactere==tab[2][size-1].charactere){    
                        return 0;
                    }
                }
            }
            
            
            if(i==0&&j==size-1){                  //cas 16
                if(tab[0][size-1].charactere==tab[1][size-1].charactere){            
                    if(tab[0][size-1].charactere==tab[size-2][size-1].charactere||tab[0][size-1].charactere==tab[size-1][size-2].charactere||tab[0][size-1].charactere==tab[size-1][0].charactere||tab[0][size-1].charactere==tab[3][size-1].charactere||tab[0][size-1].charactere==tab[2][size-2].charactere||tab[0][size-1].charactere==tab[2][0].charactere){            
                        return 0;
                    }
                }
            }
            
            
            if(i==size-2&&j==0){                  
                if(tab[size-2][0].charactere==tab[size-1][0].charactere){            //cas 17
                    if(tab[size-2][0].charactere==tab[size-4][0].charactere||tab[size-2][0].charactere==tab[size-3][1].charactere||tab[size-2][0].charactere==tab[size-3][size-1].charactere||tab[size-2][0].charactere==tab[0][1].charactere||tab[size-2][0].charactere==tab[0][size-1].charactere||tab[size-2][0].charactere==tab[1][0].charactere){   
                        return 0;
                    }
                }
            }
            
            if(i==size-2&&j==size-1){                  
                if(tab[size-2][size-1].charactere==tab[size-1][size-1].charactere){          //cas 18  
                    if(tab[size-2][size-1].charactere==tab[size-4][size-1].charactere||tab[size-2][size-1].charactere==tab[size-3][size-2].charactere||tab[size-2][size-1].charactere==tab[size-3][0].charactere||tab[size-2][size-1].charactere==tab[0][0].charactere||tab[size-2][size-1].charactere==tab[0][size-2].charactere||tab[size-2][size-1].charactere==tab[1][size-1].charactere){  
                        return 0;
                    }
                }
            }
            
            if(i==size-1&&j==size-1){                  
                if(tab[size-1][size-1].charactere==tab[0][size-1].charactere){        //cas 19    
                    if(tab[size-1][size-1].charactere==tab[size-3][size-1].charactere||tab[size-1][size-1].charactere==tab[size-2][size-2].charactere||tab[size-1][size-1].charactere==tab[size-2][0].charactere||tab[size-1][size-1].charactere==tab[1][0].charactere||tab[size-1][size-1].charactere==tab[1][size-2].charactere||tab[size-1][size-1].charactere==tab[2][size-1].charactere){         
                        return 0;
                    }
                }
            }
            
            if(i==0&&j==0){                  
                if(tab[0][0].charactere==tab[size-1][0].charactere){     //cas 20       
                    if(tab[0][0].charactere==tab[size-3][0].charactere||tab[0][0].charactere==tab[size-2][size-1].charactere||tab[0][0].charactere==tab[size-2][1].charactere||tab[0][0].charactere==tab[1][1].charactere||tab[0][0].charactere==tab[1][size-1].charactere||tab[0][0].charactere==tab[2][0].charactere){   
                        return 0;
                    }
                }
            }
            
        }
    }
    return 1;
}

///////////////////////////////////////////////////////////////////////////////////



void resume_game() {
  int size, different;
  bool verifblocage;
  long score;
  long high_score;
  
  
  square_table tab[20][20]; // D√©finition du table

  

// LOAD SAVE : -------------------------------------------------------------
  
  
  FILE* save = fopen("save_file.txt", "r");               // Ouverture du fichier de sauvegarde en mode lecture
  if (save == NULL) {                                      // Message erreur si aucun fichier de sauvegarde d√©tect√©
    printf("Erreur : Probl√®me pour ouvrir la sauvegarde");
    return;
  }


  fscanf(save, "Tab size : %d\n", &size);
  fscanf(save, "Nbr of different(s) possible symbols : %d\n", &different);
  fscanf(save, "High-Score : %ld\n", &high_score);
  fscanf(save, "Score : %ld\n", &score);
  


  for (int i=0; i < size; i++) {
    for (int k=0; k < size; k++) {
      
      fscanf(save, "%c", &tab[i][k].charactere);     // √âcriture du table dans le fichier sauvegarde
    }
  }

  fclose(save);   // Fermeture du fichier une fois √©criture termin√©e

  //---------------------------------------------------------------


  do{                                     //boucle de verifblocage
                //netoyage de la zone de jeu
    //clrscr();                                       //nettoyage du terminal
printf("Votre score est de %ld \n",score); 
    replacement(tab, size,different,score);
    Displaymoji(tab, size);        
    exchange(tab,size);            //√©change
    score=replacement(tab, size,different,score);
    verifblocage=detectionblocage(tab,size);
    
    }while(verifblocage==0);
    Displaymoji(tab, size);
    printf("C'est termin√© plus aucun mouvement n'est possible votre score est de %ld\n",score);
}



    

void setting_parameters() {
  int size, different;
  bool verifblocage;
  long score = 0;
  long high_score = 0;
 
  
  
    do {
        printf("Entrez la size du table (entre 5 et 20) : ");
        scanf("%d", &size);
    } while (size < 5 || size > 20);
    
    do {
        printf("Entrez le nombre de forme diff√©rentes (entre 4 et 6) : ");
        scanf("%d", &different);
    } while (different < 4 || different > 6);
    
    square_table tab[20][20]; // D√©finition du table
    
    srand(time(NULL)); // G√©n√©ration al√©atoire
    
    int i, k;
    for (i = 0; i < size; i++) {
        for (k = 0; k < size; k++) {
        // G√©n√©ration al√©atoire des caract√®res
        tab[i][k].charactere = 'A' + rand() % different; //  symboles diff√©rents choisit lors du scanf
        tab[i][k].variable = 0; // variable √† z√©ro pour le counter
      }
    }
    Displaymoji(tab, size);        //d√©but du jeu
    replacement(tab, size,different,score);
    score=0;
    //high_score √† d√©finir avec si aucun fichier de sauvegarde existe alors = 0 sinon = au fichier de sauvegarde
    do{                                     //boucle de verifblocage
                
      
      // FIRST SAVE : -------------------------------------------------------------
  
  
  FILE* save = fopen("save_file.txt", "w");               // Ouverture du fichier de sauvegarde en mode √©criture
  if (save == NULL) {                                      // Message erreur si aucun fichier de sauvegarde d√©tect√©
    printf("Erreur : Probl√®me pour ouvrir la sauvegarde");
    
  }

  fprintf(save, "Tab size : %d\n", size);
  fprintf(save, "Nbr of different(s) possible symbols : %d\n", different);
  fprintf(save, "Score : %ld\n", score);
  


  for (int i=0; i < size; i++) {
    for (int k=0; k < size; k++) {
      
      fprintf(save, "%c", tab[i][k].charactere);     // √âcriture du table dans le fichier sauvegarde
    }
    fprintf(save, "\n");
  }

  fclose(save);   // Fermeture du fichier une fois √©criture termin√©e

  //---------------------------------------------------------------


  FILE* save_highscore = fopen("save_highscore.txt", "r");               // Ouverture du fichier de sauvegarde en mode √©criture
  if (save_highscore == NULL) {                                      // Message erreur si aucun fichier de sauvegarde d√©tect√©
    printf("Erreur : Probl√®me pour ouvrir la sauvegarde");
    return;
  }

  fscanf(save_highscore, "High-Score : %ld\n", &high_score);
      fclose(save_highscore);
  
      
      
        if(high_score<score){
          high_score=score;
      FILE* save_highscore = fopen("save_highscore.txt", "w");               // Ouverture du fichier de sauvegarde en mode √©criture
  if (save_highscore == NULL) {                                      // Message erreur si aucun fichier de sauvegarde d√©tect√©
    printf("Erreur : Probl√®me pour ouvrir la sauvegarde");
    return;
  }

  fprintf(save_highscore, "High-Score : %ld\n", high_score);
      fclose(save_highscore);
    }

      
    printf("Votre score est de %ld \n",score);                                     
    Displaymoji(tab, size);        
    exchange(tab,size);            //√©change
    score=replacement(tab, size,different,score);
    verifblocage=detectionblocage(tab,size);
    
    }while(verifblocage==0);
    Displaymoji(tab, size);
    printf("c'est termin√© plus aucun mouvement n'est possible\nvotre score est de %ld",score);
}

////////////////////////////////////////////////////////////////////////////////////////////




void Home_menu(){
    
  char selection=0;                      // Valeur n√©cessaire pour rentrer dans la boucle while
  
  printf("\x1b[34m----------------------------------\n");
  printf("\x1b[34m--------------------------------\n");
  printf("\n");

  printf("\x1b[32mBienvenue sur CY - Crush ! :D\n ");        // Message d'accueil
  
  printf("\n");
  printf("\x1b[34m--------------------------------\n");  
  printf("\x1b[34m----------------------------------\n");
  printf(COLOR("%d"),0);

  printf("\n \n");

  printf("\x1b[32m1." "\x1B[36mNouvelle partie\n\n");               // Interface Menu muni de 4 options
  printf("\x1b[32m2." "\x1B[36mReprendre\n\n");
  printf("\x1b[32m3." "\x1B[36mCr√©dits\n\n");
  printf("\x1B[31m4. Quitter le jeu\n\n\n");
  printf(COLOR("%d"),0);
  
  
 // while (selection<1 || selection>4) {

  do{
    
    printf("\x1B[33mVeuillez entrer" "\x1B[32m [1]" "\x1B[33m," " \x1B[32m[2]" "\x1B[33," "\x1B[32m [3]" "\x1B[33m ou " "\x1B[31m[4]" "\x1B[33m :\n" );         // Demande √† l'utilisateur de faire son choix
    printf(COLOR("%d"),0);
    scanf("%s", &selection);              // R√©cuperation de la r√©ponse du joueur
    if (selection=='1'){
      
      printf("\x1B[33mC'est parti pour une nouvelle aventure ! \n");     // Lancement d'une nouvelle sauvegarde
      printf(COLOR("%d"),0);
      setting_parameters();
    }

    else if (selection=='2') {
      
      printf("\x1B[33mHeureux de te retrouver, on est reparti !\n" );      // Lancement d'une sauvegarde pr√©c√©dente
      printf(COLOR("%d"),0);
      resume_game();
    }

    else if (selection=='3') {
      
      printf("\x1B[33mCy Crush par :\n\n\n" "\x1B[34mBLUTEAU Corentin\n\n" "\x1B[32mLY Athyna\n\n" "\x1B[36mANDRIANAVALONA Timoth√©\n\n");                   // Display des cr√©dits
      printf(COLOR("%d"),0);
      selection=5;                                   // Retour au d√©but de la boucle, redemande choix du joueur

      
    }

    else if (selection=='4') {
      
      printf("\x1B[33mSalut, j'esp√®re qu'on se reverra tr√®s bient√¥t ! :D\n");     // message d'au revoir, sayonara !
      printf(COLOR("%d"),0);
      exit(0);
    }

    else {
      
      printf("\x1B[31mVeuillez r√©essayer x(\n");    // Valeur entr√©e non valide --> retour au d√©but de la boucle
      printf(COLOR("%d"),0);
    }
  }while ((selection!= '4') || (selection!= '3') || (selection!= '2') || (selection!= 1));

}




    





int main() {

  Home_menu();

return 0;
}
